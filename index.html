<!doctype html>
<html lang="en" class="dark m-0 h-full w-full px-0">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MIDI SysEx Utility</title>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/alpinejs/3.13.5/cdn.min.js"
      defer
    ></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.bunny.net" />
    <link
      href="https://fonts.bunny.net/css?family=inter:100,200,300,400,500,600,700,800|jetbrains-mono:100,200,300,400,500,600,700,800"
      rel="stylesheet"
    />

    <style>
      [x-cloak] {
        display: none;
      }
    </style>
  </head>
  <body
    class="h-full w-full overflow-hidden bg-slate-950 text-slate-200 antialiased"
  >
    <div
      x-cloak
      x-data="midiSysExUtility"
      x-on:keydown.window.shift.l="consoleOpen = !consoleOpen"
      class="flex h-full flex-col"
    >
      <header class="flex flex-row items-center justify-between px-3 py-1">
        <h1 class="text-xl font-bold text-blue-400">MIDI SysEx Utility</h1>

        <nav class="flex flex-row items-center justify-between gap-6">
          <div class="flex flex-row gap-1">
            <select
              id="midiInput"
              x-model="selectedInput"
              x-on:change="handleInputChange"
              class="input focusable w-40 !bg-slate-900"
            >
              <option value="">Select Input</option>
              <template x-for="input in midiInputs" :key="`input-${input.id}`">
                <option x-bind:value="input.id" x-text="input.name"></option>
              </template>
            </select>
            <select
              id="midiOutput"
              x-model="selectedOutput"
              x-on:change="handleOutputChange"
              class="input focusable w-40 !bg-slate-900"
            >
              <option value="">Select Output</option>
              <template
                x-for="output in midiOutputs"
                :key="`output-${output.id}`"
              >
                <option x-bind:value="output.id" x-text="output.name"></option>
              </template>
            </select>
          </div>
        </nav>
      </header>

      <div class="flex h-full flex-1 flex-row">
        <div class="h-full w-1/2 flex-1 border-r border-zinc-800">
          <textarea
            x-on:keydown.enter="sendSysex"
            x-model="sysexInput"
            class="h-full w-full resize-none bg-zinc-950 p-2 font-mono text-sm text-slate-200 outline-none focus:outline-none"
            placeholder="Enter SysEx message (e.g., F0 00 20 6B 04 00 01 03 01 00 00 00 F7)"
          ></textarea>
        </div>
        <div class="h-full w-1/2 flex-1">
          <div
            x-ref="logWindow"
            class="h-full overflow-y-auto bg-zinc-950 p-2 font-mono text-xs"
          >
            <template x-for="(log, index) in logMessages" :key="`log-${index}`">
              <div
                class="leading-4"
                x-bind:class="{
                  'text-yellow-400': log.type === 'sysex',
                  'text-green-400': log.type === 'midi',
                  'text-red-400': log.type === 'error',
                  'text-black bg-yellow-500 my-2 leading-none p-1 font-bold': log.type === 'alert',
                  'text-slate-400': !['sysex', 'midi', 'error', 'alert'].includes(log.type)
                }"
              >
                <kbd class="mr-1 opacity-50" x-text="log.timestamp"></kbd>
                <span x-text="log.message"></span>
              </div>
            </template>
          </div>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener("alpine:init", () => {
        Alpine.data("midiSysExUtility", () => ({
          midiAccess: null,
          midiInputs: [],
          midiOutputs: [],
          selectedInput: "",
          selectedOutput: "",
          sysexInput: "",
          logMessages: [],

          init() {
            if (navigator.requestMIDIAccess) {
              navigator
                .requestMIDIAccess({ sysex: true })
                .then(
                  this.onMIDISuccess.bind(this),
                  this.onMIDIFailure.bind(this),
                );
            } else {
              this.logToWindow(
                "WebMIDI is not supported in this browser.",
                "error",
              );
            }
          },

          onMIDISuccess(access) {
            this.midiAccess = access;
            this.updateDeviceLists();
            access.onstatechange = () => this.updateDeviceLists();
          },

          onMIDIFailure(error) {
            this.logToWindow("Could not access your MIDI devices:", "alert");
            this.logToWindow(error.toString(), "error");
          },

          updateDeviceLists() {
            this.midiInputs = Array.from(this.midiAccess.inputs.values());
            this.midiOutputs = Array.from(this.midiAccess.outputs.values());
          },

          handleInputChange() {
            if (this.midiAccess) {
              this.midiAccess.inputs.forEach((input) => {
                input.onmidimessage = null;
              });
              const selectedDevice = this.midiAccess.inputs.get(
                this.selectedInput,
              );
              if (selectedDevice) {
                selectedDevice.onmidimessage = this.onMIDIMessage.bind(this);
                this.logToWindow(
                  `Input changed: ${selectedDevice.name}`,
                  "info",
                );
              }
            }
          },

          handleOutputChange() {
            const selectedDevice = this.midiOutputs.find(
              (device) => device.id === this.selectedOutput,
            );
            if (selectedDevice) {
              this.logToWindow(
                `Output changed: ${selectedDevice.name}`,
                "info",
              );
            }
          },

          onMIDIMessage(event) {
            const formattedMessage = this.formatMIDIMessage(event);
            const messageType = this.isSysExMessage(event.data[0])
              ? "sysex"
              : "midi";
            this.logToWindow(formattedMessage, messageType);
          },

          logToWindow(message, type = "info") {
            const newEntry = {
              timestamp: new Date().toISOString(),
              message: message,
              type: type,
            };
            this.logMessages.push(newEntry);

            this.$nextTick(() => {
              this.scrollToBottom();
            });
          },

          scrollToBottom() {
            const logWindow = this.$refs.logWindow;
            if (logWindow) {
              logWindow.scrollTop = logWindow.scrollHeight;
            }
          },

          sendSysex() {
            const output = this.midiOutputs.find(
              (device) => device.id === this.selectedOutput,
            );
            if (!output) {
              this.logToWindow("No MIDI output selected", "error");
              return;
            }

            const sysexMessage = this.sysexInput
              .split(/\s+/)
              .map((n) => parseInt(n, 16));
            if (
              !this.isSysExMessage(sysexMessage[0]) ||
              !this.isSysExMessage(sysexMessage[sysexMessage.length - 1])
            ) {
              this.logToWindow("Invalid SysEx message format", "error");
              return;
            }

            this.logToWindow(
              "Sending: " + this.bytesToHex(sysexMessage),
              "info",
            );
            try {
              output.send(sysexMessage);
            } catch (error) {
              this.logToWindow(
                `Error sending MIDI message: ${error.message}`,
                "error",
              );
            }
          },

          // Utility functions
          bytesToHex(data, separator = " ") {
            return Array.from(data)
              .map((byte) => byte.toString(16).padStart(2, "0").toUpperCase())
              .join(separator);
          },

          formatMIDIMessage(event) {
            const [status, data1, data2] = event.data;
            const messageType = this.getMIDIMessageType(status >> 4);
            const channel = (status & 0xf) + 1;
            const hexString = this.bytesToHex(event.data);
            return `Received: Type: ${messageType}, Channel: ${channel}, Data: ${hexString}`;
          },

          getMIDIMessageType(statusByte) {
            const types = [
              "Note Off",
              "Note On",
              "Polyphonic Aftertouch",
              "Control Change",
              "Program Change",
              "Channel Aftertouch",
              "Pitch Bend",
              "System",
            ];
            return types[statusByte - 8] || "Unknown";
          },

          isSysExMessage(status) {
            return status === 0xf0 || status === 0xf7;
          },
        }));
      });
    </script>
  </body>
</html>
